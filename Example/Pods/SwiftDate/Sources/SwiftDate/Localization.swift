//
//	SwiftDate, Full featured Swift date library for parsing, validating, manipulating, and formatting dates and timezones.
//	Created by:				Daniele Margutti
//	Main contributors:		Jeroen Houtzager
//
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in
//	all copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//	THE SOFTWARE.

import Foundation

/// This class allows you to read and load a custom `.strings` file or a file generated by a gived `Locale` instance.
public class Localization {
	
	/// Translations file loaded from a custom `.strings` file.
	/// It has a valid value only if `Localization` is loaded from a file.
	private var translations: NSDictionary?
	
	/// Bundle for given locale instances
	private var bundle: Bundle?
	/// Locale instances loaded (only if initialized via Locale instance)
	private(set) var locale: Locale?
	
	
	/// Init `Localization` instance from a custom `.strings` file at given path
	///
	/// - Parameter path: path to a strings file
	/// - Throws: throw an exception if not valid `strings` file was loaded.
	public init(path: String) throws {
		guard let data = NSDictionary(contentsOfFile: path) else {
			throw DateError.InvalidLocalizationFile
		}
		translations = data
	}
	
	
	/// Initialize a new `Localization` from a given `LocaleName`
	///
	/// - Parameter name: name of locale
	public convenience init(locale name: LocaleName) {
		self.init(locale: name.locale)
	}
	
	
	/// Init `Localization` instance with a given `locale` instance
	///
	/// - Parameter locale: locale to load; if `nil` current `locale` is used instead.
	public init(locale: Locale?) {
		self.locale = locale ?? Locale.current
		
		let resourceBundle = Localization.resourceBundle()!
		let localeID = self.locale!.collatorIdentifier?.replacingOccurrences(of: "_", with: "-")
		guard let innerLanguagePath = resourceBundle.path(forResource: localeID, ofType: "lproj") else {
			
			//fallback to language only
			if let languageCode = self.locale!.languageCode {
				//example : get french traduction even though you are live in belgium
				if let localOnlyPath = resourceBundle.path(forResource: "\(languageCode)-\(languageCode.uppercased())"  , ofType: "lproj") {
					self.bundle = Bundle(path: localOnlyPath)
					return
				}
				// Sigle locale (ie. 'ar')
				if let localOnlyPath = resourceBundle.path(forResource: "\(languageCode)"  , ofType: "lproj") {
					self.bundle = Bundle(path: localOnlyPath)
					return
				}
			}
			// fallback to english if language was not found
			let englishPath = resourceBundle.path(forResource: "en-US", ofType: "lproj")!
			self.bundle = Bundle(path: englishPath)
			return
		}
		self.bundle = Bundle(path: innerLanguagePath)
	}
	
	
	/// Get translated value for a given key
	///
	/// - Parameters:
	///   - key: key to search
	///   - defValue: default fallback value. By default is empty string.
	/// - Returns: translated value
	public func get(_ key: String, default defValue: String = "") -> String {
		if translations != nil {
			guard let value = translations!.object(forKey: key) as? String else {
				return defValue
			}
			return value
		} else {
			guard let bundle = self.bundle else {
				return defValue
			}
			let value =  NSLocalizedString(key, tableName: "SwiftDate", bundle: bundle, value: "", comment: "")
			return value
		}
	}
	
	
	/// Framework's translation bundle resource
	///
	/// - Returns: path
	private class func resourceBundle() -> Bundle? {
		let framework = Bundle(for: DateInRegion.self)
		let path = NSURL(fileURLWithPath: framework.resourcePath!).appendingPathComponent("SwiftDate.bundle")
		let bundle = Bundle(url: path!)
		guard let _ = bundle else {
			return nil
		}
		return bundle!
	}
	
}
